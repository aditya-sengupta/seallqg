# Simulator of an adaptive optics system observer.
# Operates on a single mode at a time.

import numpy as np
from scipy import integrate, optimize, signal, stats, linalg
from copy import deepcopy
from matplotlib import pyplot as plt
from kfilter import KFilter

# global parameter definitions
f_sampling = 1000  # Hz
f_1 = f_sampling / 60  # lowest possible frequency of a vibration mode
f_2 = f_sampling / 3  # highest possible frequency of a vibration mode
f_w = f_sampling / 3  # frequency above which measurement noise dominates
N_vib_max = 10  # number of vibration modes to be detected
energy_cutoff = 1e-8  # proportion of total energy after which PSD curve fit ends
measurement_noise = 0.06  # milliarcseconds; pulled from previous notebook
time_id = 1  # timescale over which sysid runs. Pulled from Meimon 2010's suggested 1 Hz sysid frequency.
times = np.arange(0, time_id, 1 / f_sampling)  # array of times to operate on
a = 1e-6 # the pole location for the f^(-2/3) powerlaw

def get_psd(pos):
    return signal.welch(pos, f_sampling)[1]

def damped_harmonic(pars_model):
    A, f, k, p = pars_model
    return A * np.exp(-k * 2 * np.pi * f * times) * np.cos(2 * np.pi * f * np.sqrt(1 - k**2) * times - p)


def make_psd(pars_model):
    s = damped_harmonic(pars_model)
    return signal.welch(s, fs=f_sampling, nfft=max(1000, len(s)//2))[1]

def log_likelihood(func, data):
    def get_ll(pars):
        pars_model, sd = pars[:-1], pars[-1]
        data_predicted = func(pars_model)
        LL = -np.sum(stats.norm.logpdf(data, loc=data_predicted, scale=sd))
        return LL

    return get_ll

def psd_f(f):
    def get_psd_f(pars):
        k = pars[0]
        return make_psd([1, f, k, np.pi])

    return get_psd_f

def vibe_fit_freq(psd, N=N_vib_max):
    # takes in the frequency axis for a PSD, and the PSD.
    # returns a 4xN np array with fit parameters, and a 1xN np array with variances.
    freqs = np.linspace(0, f_sampling / 2, len(psd))
    par0 = [1e-4, 1]
    PARAMS_SIZE = 2
    width = max(1, int(np.ceil(1/(freqs[1] - freqs[0]))))

    peaks = []
    unsorted_peaks = signal.find_peaks(psd)[0]
    freqs_energy = np.flip(np.argsort(psd)) # frequencies ordered by their energy
    for f in freqs_energy:
        if f in unsorted_peaks and f_1 <= f <= f_2:
            peaks.append(f)

    params = np.zeros((N, PARAMS_SIZE))
    variances = np.zeros(N)

    i = 0
    for peak_ind in peaks:
        if i >= N:
            break
        if np.any(np.abs(params[:,0] - peak_ind) <= width) or freqs[peak_ind] < f_1 + width or freqs[peak_ind] > f_2 - width:
            continue
        l, r = peak_ind - width, peak_ind + width
        windowed = psd[l:r]
        psd_ll = log_likelihood(lambda pars: psd_f(freqs[peak_ind])(pars)[l:r], windowed)
        k, sd = optimize.minimize(psd_ll, par0, method='Nelder-Mead').x
        params[i] = [freqs[peak_ind], k]
        variances[i] = sd ** 2
        i += 1

    return params, variances

def make_state_transition_vibe(params):
    STATE_SIZE = 2 * params.shape[0]
    A = np.zeros((STATE_SIZE, STATE_SIZE))
    for i in range(STATE_SIZE // 2):
        f, k = params[i]
        w0 = 2 * np.pi * f / np.sqrt(1 - k**2)
        A[2 * i][2 * i] = 2 *  np.exp(-k * w0 / f_sampling) * np.cos(w0 * np.sqrt(1 - k**2) / f_sampling)
        A[2 * i][2 * i + 1] = -np.exp(-2 * k * w0 / f_sampling)
        A[2 * i + 1][2 * i] = 1
    return A

def make_kfilter_vibe(params, variances):
    # takes in parameters and variances from which to make a physics simulation
    # and measurements to match it against.
    # returns a KFilter object.
    A = make_state_transition_vibe(params)
    STATE_SIZE = 2 * params.shape[0]
    state = np.zeros(STATE_SIZE)
    H = np.array([[1, 0] * (STATE_SIZE // 2)])
    Q = np.zeros((STATE_SIZE, STATE_SIZE))
    for i in range(variances.size):
        Q[2 * i][2 * i] = variances[i]
    R = measurement_noise**2 * np.identity(1)
    return KFilter(A, B, C, Q, R)

def make_kfilter_turb(impulse):
    # takes in an impulse response as generated by make_impulse, and a 'calibration' array with the first N openloop measurements, 
    # and returns a KFilter object.
    n = impulse.size
    state = np.zeros(n,)
    A = np.zeros((n, n))
    for i in range(1, n):
        A[i][i-1] = 1
    A[0] = (np.real(impulse)/sum(np.real(impulse)))
    Q = np.zeros((n,n))
    Q[0][0] = 1 # arbitrary: I have no idea how to set this yet.
    C = np.zeros((1,n))
    C[:,0] = 1
    R = np.array([measurement_noise**2])
    return KFilter(A, Q, C, R)

def make_kfilter_ar(ar_len, openloops, sigma=0.06):
    n = len(openloops)
    TTs_mat = np.empty(n - ar_len, ar_len)
    for i in range(ar_len):
        TTs_mat[:, i] = openloops[ar_len - i + 1 : n - i] 

    ar_coef = np.linalg.solve(TTs_mat, openloops[ar_len + 1:])
    ar_residual = openloops[ar_len:-1] - (TTs_mat @ ar_coef)
    A = np.zeros((ar_len, ar_len))
    A[1,:] = ar_coef
    for i in range(1, ar_len):
        A[i,i-1] += 1.0

    B = np.zeros((ar_len, 1)) # need to change this for control delay
    B[1] = 1.0 # input just hits the current x
    C = np.zeros((1, ar_len))
    C[1] += 1

    Q = np.zeros((ar_len, ar_len))
    Q[1,1] = np.mean(ar_residual ** 2)

    R = np.array([[Ïƒ^2]])

    return KFilter(A, B, C, Q, R)
